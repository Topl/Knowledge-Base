"use strict";(self.webpackChunkportal=self.webpackChunkportal||[]).push([[426],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),d=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(a),m=n,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||l;return a?r.createElement(h,i(i({ref:t},p),{},{components:a})):r.createElement(h,i({ref:t},p))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var d=2;d<l;d++)i[d]=a[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},5516:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var r=a(7462),n=(a(7294),a(3905));const l={title:"Topl Blockchain Address",slug:"how-topl-addresses-are-generated",hidden:!1,createdAt:"2021-03-25T20:26:06.337Z",updatedAt:"2021-04-15T14:27:00.123Z"},i=void 0,o={unversionedId:"Developer/New To Topl/how-topl-addresses-are-generated",id:"Developer/New To Topl/how-topl-addresses-are-generated",title:"Topl Blockchain Address",description:"The Topl blockchain address is a unique sequence of numbers and letters that functions similarly to an email address. In particular, the numbers and letters are Base58 encoded.  The Topl blockchain address refers to a specific destination on the network to which assets can. For example, imagine that you want to make a transaction on the Topl network with your friend Bob. Bob will share his address with you and you will be able to transact with him via this address.",source:"@site/docs/Developer/New To Topl/how-topl-addresses-are-generated.md",sourceDirName:"Developer/New To Topl",slug:"/Developer/New To Topl/how-topl-addresses-are-generated",permalink:"/Developer/New To Topl/how-topl-addresses-are-generated",draft:!1,editUrl:"https://github.com/Topl/knowledge-base/edit/main/docs/Developer/New To Topl/how-topl-addresses-are-generated.md",tags:[],version:"current",frontMatter:{title:"Topl Blockchain Address",slug:"how-topl-addresses-are-generated",hidden:!1,createdAt:"2021-03-25T20:26:06.337Z",updatedAt:"2021-04-15T14:27:00.123Z"}},s={},d=[{value:"Generate an Address",id:"generate-an-address",level:2},{value:"Step 1: Add the network prefix",id:"step-1-add-the-network-prefix",level:3},{value:"Step 2: Append the propositionType prefix",id:"step-2-append-the-propositiontype-prefix",level:3},{value:"Step 3: Append the evidence content",id:"step-3-append-the-evidence-content",level:3},{value:"Step 4: Append the address checksum",id:"step-4-append-the-address-checksum",level:3},{value:"Step 5: Convert into Base58",id:"step-5-convert-into-base58",level:3},{value:"Generate an address using the BramblJS KeyManager module",id:"generate-an-address-using-the-brambljs-keymanager-module",level:2},{value:"Generate an address using the BramblSc KeyRing",id:"generate-an-address-using-the-bramblsc-keyring",level:2},{value:"Generate multiple addresses using the BramblSC KeyRing",id:"generate-multiple-addresses-using-the-bramblsc-keyring",level:2},{value:"Import Bifrost Keyfile",id:"import-bifrost-keyfile",level:2},{value:"Import Keyfile BramblSC",id:"import-keyfile-bramblsc",level:2}],p={toc:d};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"The Topl blockchain address is a unique sequence of numbers and letters that functions similarly to an email address. In particular, the numbers and letters are ",(0,n.kt)("a",{parentName:"p",href:"https://tools.ietf.org/id/draft-msporny-base58-01.html"},"Base58")," encoded.  The Topl blockchain address refers to a specific destination on the network to which assets can. For example, imagine that you want to make a transaction on the Topl network with your friend Bob. Bob will share his address with you and you will be able to transact with him via this address."),(0,n.kt)("h2",{id:"generate-an-address"},"Generate an Address"),(0,n.kt)("p",null,"Our public and private keys are generated using the <<glossary:Curve25519>> algorithm. You get a reference for your address in the following way:"),(0,n.kt)("h3",{id:"step-1-add-the-network-prefix"},"Step 1: Add the network prefix"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The network prefix allows nodes on the Topl network to verify which network the address is on")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Network Prefix"),(0,n.kt)("th",{parentName:"tr",align:null},"Network"),(0,n.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x01"),(0,n.kt)("td",{parentName:"tr",align:null},"Topl Public Mainnet"),(0,n.kt)("td",{parentName:"tr",align:null},"Not yet available in Beta")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x10"),(0,n.kt)("td",{parentName:"tr",align:null},"Valhalla Public Testnet"),(0,n.kt)("td",{parentName:"tr",align:null},"Line in Beta")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x30"),(0,n.kt)("td",{parentName:"tr",align:null},"Local Developer Network"),(0,n.kt)("td",{parentName:"tr",align:null},"Used for <<glossary:Bifrost>>  Developers")))),(0,n.kt)("h3",{id:"step-2-append-the-propositiontype-prefix"},"Step 2: Append the propositionType prefix"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Topl supports addresses with public/private key pairs that are generated using two different algorithms.")),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Prefix"),(0,n.kt)("th",{parentName:"tr",align:null},"propositionType"),(0,n.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x01"),(0,n.kt)("td",{parentName:"tr",align:null},"Curve25519 Public Key Hash"),(0,n.kt)("td",{parentName:"tr",align:null},"Default Implementation by Brambl KeyManager")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x02"),(0,n.kt)("td",{parentName:"tr",align:null},"Curve25519 Threshold Hash"),(0,n.kt)("td",{parentName:"tr",align:null},"Another implementation accepted by the Topl Network")))),(0,n.kt)("h3",{id:"step-3-append-the-evidence-content"},"Step 3: Append the evidence content"),(0,n.kt)("p",null,"The evident content is a 32 byte commitment to the proposition that must be supplied and satisfied by the transaction issuer."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"propositionType"),(0,n.kt)("th",{parentName:"tr",align:null},"Generation Method"),(0,n.kt)("th",{parentName:"tr",align:null},"Notes"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x01"),(0,n.kt)("td",{parentName:"tr",align:null},"Blake2b-256 Hash of the Public Key"),(0,n.kt)("td",{parentName:"tr",align:null},"For Curve25519 Public Key Hash")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"0x02"),(0,n.kt)("td",{parentName:"tr",align:null},"Blake2b-256 Hash of all public keys in the threshold proposition"),(0,n.kt)("td",{parentName:"tr",align:null},"For Threshold Hash")))),(0,n.kt)("h3",{id:"step-4-append-the-address-checksum"},"Step 4: Append the address checksum"),(0,n.kt)("p",null,"Finally, add the first 4 bytes of the Blake2b-256 hash of the preceding 34 bytes."),(0,n.kt)("h3",{id:"step-5-convert-into-base58"},"Step 5: Convert into Base58"),(0,n.kt)("p",null,"The last step is to convert the address that you get after appending the four pieces of information into Base58."),(0,n.kt)("h2",{id:"generate-an-address-using-the-brambljs-keymanager-module"},"Generate an address using the BramblJS KeyManager module"),(0,n.kt)("p",null,"The easiest way to generate an address is using the Brambl KeyManager Module. An example of this is shown in the ",(0,n.kt)("strong",{parentName:"p"},"recipe")," below."),(0,n.kt)("p",null,"The KeyManager module is compliant with Bifrost's Gjallarhorn Key Manager service and provides an straightforward interface for creating new keyfiles as well as creating and verifying signatures on transactions. New encrypted keyfiles are generated using Curve25519 key pairs and are encrypted using an AES-256 cipher with a user-specified password. All data within the keyfile is encoded using Base58."),(0,n.kt)("p",null,"[block:tutorial-tile]",'\n{\n"title": "Create Topl Address using BramblJS",\n"emoji": "\ud83d\udc90",\n"backgroundColor": "#2c5572",\n"slug": "create-topl-address-using-brambljs",\n"_id": "62e99eede9a6470167b86ece",\n"id": "62e99eede9a6470167b86ece",\n"link": "',(0,n.kt)("a",{parentName:"p",href:"https://topl.readme.io/v1.3.0/recipes/create-topl-address-using-brambljs%22"},'https://topl.readme.io/v1.3.0/recipes/create-topl-address-using-brambljs"'),"\n}\n","[/block]"),(0,n.kt)("h2",{id:"generate-an-address-using-the-bramblsc-keyring"},"Generate an address using the BramblSc KeyRing"),(0,n.kt)("p",null,"If you are using BramblSc, it is also simple to generate and address. An example is shown below"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'val address = brambl.keyRing.DiskOps.generateKeyFile(\\"password\\").get\n')),(0,n.kt)("h2",{id:"generate-multiple-addresses-using-the-bramblsc-keyring"},"Generate multiple addresses using the BramblSC KeyRing"),(0,n.kt)("p",null,"First, let's initialize our BramblSC instance, then create 3 addresses using the KeyRing."),(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"The password to encrypt the keyfile used must be encoded in Latin-1. In addition, please replace {{myProjectId}} with your projectID.")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'val provider: Provider = ValhallaTestNet(apiKey = "myApiKey", uri = "https://staging.vertx.topl.services/valhalla/{{myProjectId}}")\nval brambl: Brambl = Brambl.standalone("./my_key_directory",Some( provider))\n\nval addrs: Set[Address] = brambl.keyRing.generateNewKeyPairs(3) match {\n  case Failure(exception) => throw exception\n  case Success(value) => value.map(_.publicImage.address(brambl.networkPrefix))\n}\n')),(0,n.kt)("h2",{id:"import-bifrost-keyfile"},"Import Bifrost Keyfile"),(0,n.kt)("p",null,"If you are a Bifrost Developer, you can also import keys generated by Bifrost's Gjallarhorn KeyManager. An example is shown in the recipe below."),(0,n.kt)("p",null,"[block:tutorial-tile]",'\n{\n"title": "Create Topl Address from Curve25519 KeyFile",\n"emoji": "\ud83c\udf65",\n"backgroundColor": "#331f51",\n"slug": "create-topl-address-from-curve25519-keyfile",\n"_id": "62e99eede9a6470167b86ecf",\n"id": "62e99eede9a6470167b86ecf",\n"link": "',(0,n.kt)("a",{parentName:"p",href:"https://topl.readme.io/v1.3.0/recipes/create-topl-address-from-curve25519-keyfile%22"},'https://topl.readme.io/v1.3.0/recipes/create-topl-address-from-curve25519-keyfile"'),"\n}\n","[/block]"),(0,n.kt)("h2",{id:"import-keyfile-bramblsc"},"Import Keyfile BramblSC"),(0,n.kt)("p",null,"In addition, you can also import keys generated by BramblSC's KeyRing. An example is shown below."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-scala"},'val provider: Provider = ValhallaTestNet(apiKey = "myApiKey", uri = "https://staging.vertx.topl.services/valhalla/{{myProjectId}}\\")\nval brambl: Brambl = Brambl.standalone("./my_key_directory",Some( provider))\n\nval address1 = brambl.keyRing.DiskOps.unlockKeyFile("base58_encoded_address", "password") match {\n  case Failure(exception) => throw exception\n  case Success(value) => value\n}\n')),(0,n.kt)("admonition",{type:"caution"},(0,n.kt)("p",{parentName:"admonition"},"The string for the address has to be the same as the address generated by BramblSC and the naming convention for the keyfile has to include ","\\","<address","\\",">.json. \\n\\nIn addition, BramblSC checks the whole directory for valid keyfiles so if there are other files in your key file directory that are not valid keys, or that are from different networks, then BramblSC will throw a validation error.")))}u.isMDXComponent=!0}}]);