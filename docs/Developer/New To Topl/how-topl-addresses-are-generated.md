---
title: "Topl Blockchain Address"
slug: "how-topl-addresses-are-generated"
hidden: false
createdAt: "2021-03-25T20:26:06.337Z"
updatedAt: "2021-04-15T14:27:00.123Z"
---
The Topl blockchain address is a unique sequence of numbers and letters that functions similarly to an email address. In particular, the numbers and letters are [Base58](https://tools.ietf.org/id/draft-msporny-base58-01.html) encoded.  The Topl blockchain address refers to a specific destination on the network to which assets can. For example, imagine that you want to make a transaction on the Topl network with your friend Bob. Bob will share his address with you and you will be able to transact with him via this address.

## Generate an Address

Our public and private keys are generated using the <<glossary:Curve25519>> algorithm. You get a reference for your address in the following way:

### Step 1: Add the network prefix

- The network prefix allows nodes on the Topl network to verify which network the address is on

| Network Prefix | Network                 | Notes                                     |
| -------------- | ----------------------- | ----------------------------------------- |
| 0x01           | Topl Public Mainnet     | Not yet available in Beta                 |
| 0x10           | Valhalla Public Testnet | Line in Beta                              |
| 0x30           | Local Developer Network | Used for <<glossary:Bifrost>>  Developers |

### Step 2: Append the propositionType prefix

- Topl supports addresses with public/private key pairs that are generated using two different algorithms.

| Prefix | propositionType            | Notes                                               |
| ------ | -------------------------- | --------------------------------------------------- |
| 0x01   | Curve25519 Public Key Hash | Default Implementation by Brambl KeyManager         |
| 0x02   | Curve25519 Threshold Hash  | Another implementation accepted by the Topl Network |

### Step 3: Append the evidence content

The evident content is a 32 byte commitment to the proposition that must be supplied and satisfied by the transaction issuer.

| propositionType | Generation Method | Notes |
| --- | --- | --- |
| 0x01 | Blake2b-256 Hash of the Public Key | For Curve25519 Public Key Hash |
| 0x02 | Blake2b-256 Hash of all public keys in the threshold proposition | For Threshold Hash |

### Step 4: Append the address checksum

Finally, add the first 4 bytes of the Blake2b-256 hash of the preceding 34 bytes.

### Step 5: Convert into Base58

The last step is to convert the address that you get after appending the four pieces of information into Base58.


## Generate an address using the BramblJS KeyManager module

The easiest way to generate an address is using the Brambl KeyManager Module. An example of this is shown in the **recipe** below.

The KeyManager module is compliant with Bifrost's Gjallarhorn Key Manager service and provides an straightforward interface for creating new keyfiles as well as creating and verifying signatures on transactions. New encrypted keyfiles are generated using Curve25519 key pairs and are encrypted using an AES-256 cipher with a user-specified password. All data within the keyfile is encoded using Base58.

[block:tutorial-tile]
{
  "title": "Create Topl Address using BramblJS",
  "emoji": "ðŸ’",
  "backgroundColor": "#2c5572",
  "slug": "create-topl-address-using-brambljs",
  "_id": "62e99eede9a6470167b86ece",
  "id": "62e99eede9a6470167b86ece",
  "link": "https://topl.readme.io/v1.3.0/recipes/create-topl-address-using-brambljs"
}
[/block]

## Generate an address using the BramblSc KeyRing

If you are using BramblSc, it is also simple to generate and address. An example is shown below

```scala
val address = brambl.keyRing.DiskOps.generateKeyFile(\"password\").get
```

## Generate multiple addresses using the BramblSC KeyRing

First, let's initialize our BramblSC instance, then create 3 addresses using the KeyRing.

:::info

The password to encrypt the keyfile used must be encoded in Latin-1. In addition, please replace {{myProjectId}} with your projectID.

:::

```scala
val provider: Provider = ValhallaTestNet(apiKey = "myApiKey", uri = "https://staging.vertx.topl.services/valhalla/{{myProjectId}}")
val brambl: Brambl = Brambl.standalone("./my_key_directory",Some( provider))

val addrs: Set[Address] = brambl.keyRing.generateNewKeyPairs(3) match {
  case Failure(exception) => throw exception
  case Success(value) => value.map(_.publicImage.address(brambl.networkPrefix))
}
```

## Import Bifrost Keyfile

If you are a Bifrost Developer, you can also import keys generated by Bifrost's Gjallarhorn KeyManager. An example is shown in the recipe below.

[block:tutorial-tile]
{
  "title": "Create Topl Address from Curve25519 KeyFile",
  "emoji": "ðŸ¥",
  "backgroundColor": "#331f51",
  "slug": "create-topl-address-from-curve25519-keyfile",
  "_id": "62e99eede9a6470167b86ecf",
  "id": "62e99eede9a6470167b86ecf",
  "link": "https://topl.readme.io/v1.3.0/recipes/create-topl-address-from-curve25519-keyfile"
}
[/block]

## Import Keyfile BramblSC

In addition, you can also import keys generated by BramblSC's KeyRing. An example is shown below.

```scala
val provider: Provider = ValhallaTestNet(apiKey = "myApiKey", uri = "https://staging.vertx.topl.services/valhalla/{{myProjectId}}\")
val brambl: Brambl = Brambl.standalone("./my_key_directory",Some( provider))

val address1 = brambl.keyRing.DiskOps.unlockKeyFile("base58_encoded_address", "password") match {
  case Failure(exception) => throw exception
  case Success(value) => value
}
```

:::caution

The string for the address has to be the same as the address generated by BramblSC and the naming convention for the keyfile has to include \\<address\\>.json. \n\nIn addition, BramblSC checks the whole directory for valid keyfiles so if there are other files in your key file directory that are not valid keys, or that are from different networks, then BramblSC will throw a validation error.

:::
